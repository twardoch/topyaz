#!/usr/bin/env python3
# this_file: src/topyaz/utils/validation.py
"""
File validation utilities for topyaz.

This module provides utilities for validating output files generated by
Topaz products, including file integrity checks and comparison with input files.
"""

import json  # Moved from _get_video_info
import mimetypes

# import os # F401: Unused import
import shutil  # Moved from _get_video_info
import subprocess
from pathlib import Path
from typing import Any  # Optional removed

from loguru import logger
from PIL import Image  # Moved from _get_image_info

from topyaz.core.types import ProcessingResult


def validate_output_file(input_path: Path, output_path: Path) -> dict[str, Any]:
    """
    Validate that an output file was generated correctly.

    Args:
        input_path: Path to the input file
        output_path: Path to the output file

    Returns:
        Dictionary with validation results
    """
    result = {
        "file_exists": False,
        "file_size": 0,
        "size_compared_to_input": 0.0,
        "mime_type": None,
        "is_valid_format": False,
        "media_info": {},
        "errors": [],
    }

    # Check if file exists
    if not output_path.exists():
        result["errors"].append(f"Output file does not exist: {output_path}")
        return result

    result["file_exists"] = True

    # Get file size
    try:
        result["file_size"] = output_path.stat().st_size
        input_size = input_path.stat().st_size if input_path.exists() else 0

        if input_size > 0:
            result["size_compared_to_input"] = result["file_size"] / input_size

    except Exception as e:
        result["errors"].append(f"Failed to get file size: {e}")

    # Check MIME type
    try:
        mime_type, _ = mimetypes.guess_type(str(output_path))
        result["mime_type"] = mime_type

        # Basic format_output validation
        if mime_type:
            if mime_type.startswith(("image/", "video/")):
                result["is_valid_format"] = True
            else:
                result["errors"].append(f"Unexpected MIME type: {mime_type}")

    except Exception as e:
        result["errors"].append(f"Failed to determine MIME type: {e}")

    # Try to get media info for images/videos
    if result["is_valid_format"]:
        try:
            result["media_info"] = get_media_info(output_path)
        except Exception as e:
            result["errors"].append(f"Failed to get media info: {e}")

    return result


def get_media_info(file_path: Path) -> dict[str, Any]:
    """
    Get media information about an image or video file.

    Args:
        file_path: Path to the media file

    Returns:
        Dictionary with media information
    """
    info = {}

    # Try to use ffprobe for video files
    if file_path.suffix.lower() in [".mp4", ".mov", ".avi", ".mkv"]:
        info.update(_get_video_info(file_path))

    # Try to use other methods for image files
    elif file_path.suffix.lower() in [".jpg", ".jpeg", ".png", ".tiff", ".tif"]:
        info.update(_get_image_info(file_path))

    return info


def _get_video_info(file_path: Path) -> dict[str, Any]:
    """Get video file information using ffprobe."""
    info = {}

    try:
        # import shutil # Moved to top

        ffprobe_path = shutil.which("ffprobe")
        if not ffprobe_path:
            logger.warning("ffprobe executable not found in PATH.")
            return info

        # Try ffprobe first
        # S603: file_path is an argument, shell=False. ffprobe path is resolved.
        cmd = [ffprobe_path, "-v", "quiet", "-print_format", "json", "-show_format", "-show_streams", str(file_path)]

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30, check=False)  # noqa: S603

        if result.returncode == 0:
            # import json # Moved to top
            data = json.loads(result.stdout)

            # Extract format_output info
            if "format_output" in data:
                format_info = data["format_output"]
                info["duration"] = float(format_info.get("duration", 0))
                info["size"] = int(format_info.get("size", 0))
                info["format_name"] = format_info.get("format_name", "")
                info["bit_rate"] = int(format_info.get("bit_rate", 0))

            # Extract video stream info
            video_streams = [s for s in data.get("streams", []) if s.get("codec_type") == "video"]
            if video_streams:
                stream = video_streams[0]
                info["codec"] = stream.get("codec_name", "")
                info["width"] = int(stream.get("width", 0))
                info["height"] = int(stream.get("height", 0))
                info["fps"] = _parse_fps(stream.get("r_frame_rate", "0/1"))
                info["pixel_format"] = stream.get("pix_fmt", "")

            # Extract audio stream info
            audio_streams = [s for s in data.get("streams", []) if s.get("codec_type") == "audio"]
            if audio_streams:
                stream = audio_streams[0]
                info["audio_codec"] = stream.get("codec_name", "")
                info["sample_rate"] = int(stream.get("sample_rate", 0))
                info["channels"] = int(stream.get("channels", 0))

        else:
            logger.warning(f"ffprobe failed for {file_path}: {result.stderr}")

    except subprocess.TimeoutExpired:
        logger.warning(f"ffprobe timeout for {file_path}")
    except Exception as e:
        logger.warning(f"Failed to get video info for {file_path}: {e}")

    return info


def _get_image_info(file_path: Path) -> dict[str, Any]:
    """Get image file information."""
    info = {}

    try:
        # Try using PIL/Pillow if available
        # from PIL import Image # Moved to top
        with Image.open(file_path) as img:
            info["width"] = img.width
            info["height"] = img.height
            info["format_output"] = img.format
            info["mode"] = img.mode

            # Get DPI if available
            if hasattr(img, "info") and "dpi" in img.info:
                info["dpi"] = img.info["dpi"]

    except ImportError:
        logger.warning("PIL/Pillow not available for image info")
    except Exception as e:
        logger.warning(f"Failed to get image info for {file_path}: {e}")

    return info


def _parse_fps(fps_str: str) -> float:
    """Parse frame rate from ffprobe format_output (e.g., '30/1')."""
    try:
        if "/" in fps_str:
            num, denom = fps_str.split("/")
            return float(num) / float(denom)
        return float(fps_str)
    except (ValueError, ZeroDivisionError):
        return 0.0


def compare_media_files(input_path: Path, output_path: Path) -> dict[str, Any]:
    """
    Compare input and output media files to validate processing results.

    Args:
        input_path: Path to the input file
        output_path: Path to the output file

    Returns:
        Dictionary with comparison results
    """
    comparison = {
        "input_valid": False,
        "output_valid": False,
        "size_ratio": 0.0,
        "resolution_changed": False,
        "format_changed": False,
        "issues": [],
        "input_info": {},
        "output_info": {},
    }

    # Validate input file
    if input_path.exists():
        comparison["input_valid"] = True
        try:
            comparison["input_info"] = get_media_info(input_path)
        except Exception as e:
            comparison["issues"].append(f"Failed to analyze input file: {e}")
    else:
        comparison["issues"].append(f"Input file does not exist: {input_path}")

    # Validate output file
    output_validation = validate_output_file(input_path, output_path)
    comparison["output_valid"] = output_validation["file_exists"] and output_validation["is_valid_format"]
    comparison["output_info"] = output_validation["media_info"]
    comparison["size_ratio"] = output_validation["size_compared_to_input"]

    if output_validation["errors"]:
        comparison["issues"].extend(output_validation["errors"])

    # Compare resolution if both files are valid
    if comparison["input_valid"] and comparison["output_valid"]:
        input_info = comparison["input_info"]
        output_info = comparison["output_info"]

        # Check resolution changes
        if all(k in input_info for k in ["width", "height"]) and all(k in output_info for k in ["width", "height"]):
            input_res = (input_info["width"], input_info["height"])
            output_res = (output_info["width"], output_info["height"])
            comparison["resolution_changed"] = input_res != output_res

            # Log resolution change details
            if comparison["resolution_changed"]:
                logger.info(f"Resolution changed from {input_res} to {output_res}")

        # Check format_output changes
        input_format = input_path.suffix.lower()
        output_format = output_path.suffix.lower()
        comparison["format_changed"] = input_format != output_format

    return comparison


def enhance_processing_result(result: ProcessingResult) -> ProcessingResult:
    """
    Enhance a ProcessingResult with file validation information.

    Args:
        result: Original processing result

    Returns:
        Enhanced processing result with validation info
    """
    if not result.success or not result.output_path:
        return result

    try:
        # Validate output file
        validation = validate_output_file(result.input_path, result.output_path)

        # Compare with input
        comparison = compare_media_files(result.input_path, result.output_path)

        # Add validation info to additional_info
        result.additional_info.update({"output_validation": validation, "file_comparison": comparison})

        # Update success status based on validation
        if not validation["file_exists"] or not validation["is_valid_format"]:
            result.success = False
            if not result.error_message:
                result.error_message = "Output file validation failed"

        # Log issues
        all_issues = validation.get("errors", []) + comparison.get("issues", [])
        for issue in all_issues:
            logger.warning(f"Validation issue: {issue}")

    except Exception as e:
        logger.error(f"Failed to validate processing result: {e}")
        result.additional_info["validation_error"] = str(e)

    return result
